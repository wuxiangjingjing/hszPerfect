享元模式
 　　顾名思义：共享元对象。如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝，而不必
为每一次使用创建新的对象。
享元模式是为数不多的、只为提升系统性能而生的设计模式。它的主要作用就是复用大对象（重量级对象），以节省内存空间和对象创建时间。

模式结构
Flyweight:享元接口，通过这个接口Flyweight可以接受并作用于外部状态。痛过这个接口可以传入外部的状态，
在享元对象的方法处理中可能会使用这些外部的数据。

ConcreteFlyweight:具体的享元实现对象，必须是共享的，需要封装Flyweight的内部状态。

UnshareConcreteFlyweight:非共享的享元实现对象，并不是所有的Flyweight实现对象都需要共享。
非共享的享元实现对象通常是对享元对象的组合对象。

FlyweightFactoty:享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口。

Client: 享元客户端，主要的工作就是维持一个对Flyweight的引用，计算或存储享元的外部状态，
当然这里可访问共享和不共享的Flyweight对象。



纯享元模式
●抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。

●具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。

●享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。
    当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否 已经有一个符合要求的享元对象。
    如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，
    享元工厂角色就应当创建一个合适的享元对象。



模式的优缺点
模式的优点
    减少对象数量，节省内存空间。
模式的缺点
    维护共享对象，需要额外开销。（比如：一个线程来回收垃圾）
思考
    模式本质：分离和共享

开发中的应用场景：
    享元模式由于其共享的特征，可以在任何“池”中操作，比如：线程池，数据库连接池。
    String类的设计也是享元模式。